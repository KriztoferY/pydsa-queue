{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introducing PyDSA - Queue \u00b6 PyDSA - Queue ( pydsa-queue ) is a suite of Python namespaced packages that provides implementations of the Queue ADT and related algorithms. Two implementations of the Queue ADT are included in the project off the shelf: CircArrayQueue : Circular array based implementation SLListQueue : Singly linked list based implementation Different implementations of the Queue ADT are defined in separate modules. from pydsa.queue import CircArrayQueue q = CircArrayQueue [ int ]( 4 , 'int' ) print ( f \"element type: ' { q . element_type } '\" ) # ~> \"element type: 'int'\" for x in ( 3 , 1 , 4 , 1 , 5 ): q . enqueue ( x ) print ( q ) # ~> \"[3,1,4,1,5]\" for x in q : print ( f ' { x } ' , end = '' ) print () # ~> \"3 1 4 1 5\" while not q . empty : print ( f 'dequeue: front = { q . front () } | size = { len ( q ) } ' ) q . dequeue () print ( q , f '(queue is empty: { q . empty } )' ) # ~> \"[] (queue is empty: True)\" A collection of ADT-implementation-agnostic algorithms on the Queue ADT is included in a dedicated module. from operator import gt from pydsa.queue import CircArrayQueue from pydsa.queue.algo import merge nums1 = ( 4 , 7 , 2 , 10 ) q1 = CircArrayQueue [ int ]( len ( nums1 ), 'int' ) for num in nums1 : q1 . enqueue ( num ) nums2 = ( 3 , 6 , 8 , 9 , 5 , 1 ) q2 = CircArrayQueue [ int ]( len ( nums2 ), 'int' ) for num in nums2 : q2 . enqueue ( num ) merged = merge ( q1 , q2 , gt ) print ( f 'merged : { merged } ' ) # ~> \"merged : [4,7,3,6,8,9,5,2,10,1]\" Getting Started \u00b6 Here's what you need to get started. Dependencies Installation License Dependencies \u00b6 Not much. Python 3.7+ is the only dependency. Installation \u00b6 Just use pip . pip install - U pydsa - queue License \u00b6 pydsa-queue is licensed under the BSD 3-Clause License . Also Want It In Another Language? \u00b6 C : Repository | Documentation C++ : Repository | Documentation Go : Repository | Documentation [coming soon] TypeScript : Repository | Documentation","title":"Welcome"},{"location":"index.html#introducing-pydsa-queue","text":"PyDSA - Queue ( pydsa-queue ) is a suite of Python namespaced packages that provides implementations of the Queue ADT and related algorithms. Two implementations of the Queue ADT are included in the project off the shelf: CircArrayQueue : Circular array based implementation SLListQueue : Singly linked list based implementation Different implementations of the Queue ADT are defined in separate modules. from pydsa.queue import CircArrayQueue q = CircArrayQueue [ int ]( 4 , 'int' ) print ( f \"element type: ' { q . element_type } '\" ) # ~> \"element type: 'int'\" for x in ( 3 , 1 , 4 , 1 , 5 ): q . enqueue ( x ) print ( q ) # ~> \"[3,1,4,1,5]\" for x in q : print ( f ' { x } ' , end = '' ) print () # ~> \"3 1 4 1 5\" while not q . empty : print ( f 'dequeue: front = { q . front () } | size = { len ( q ) } ' ) q . dequeue () print ( q , f '(queue is empty: { q . empty } )' ) # ~> \"[] (queue is empty: True)\" A collection of ADT-implementation-agnostic algorithms on the Queue ADT is included in a dedicated module. from operator import gt from pydsa.queue import CircArrayQueue from pydsa.queue.algo import merge nums1 = ( 4 , 7 , 2 , 10 ) q1 = CircArrayQueue [ int ]( len ( nums1 ), 'int' ) for num in nums1 : q1 . enqueue ( num ) nums2 = ( 3 , 6 , 8 , 9 , 5 , 1 ) q2 = CircArrayQueue [ int ]( len ( nums2 ), 'int' ) for num in nums2 : q2 . enqueue ( num ) merged = merge ( q1 , q2 , gt ) print ( f 'merged : { merged } ' ) # ~> \"merged : [4,7,3,6,8,9,5,2,10,1]\"","title":"Introducing PyDSA - Queue "},{"location":"index.html#getting-started","text":"Here's what you need to get started. Dependencies Installation License","title":"Getting Started "},{"location":"index.html#dependencies","text":"Not much. Python 3.7+ is the only dependency.","title":"Dependencies"},{"location":"index.html#installation","text":"Just use pip . pip install - U pydsa - queue","title":"Installation"},{"location":"index.html#license","text":"pydsa-queue is licensed under the BSD 3-Clause License .","title":"License"},{"location":"index.html#also-want-it-in-another-language","text":"C : Repository | Documentation C++ : Repository | Documentation Go : Repository | Documentation [coming soon] TypeScript : Repository | Documentation","title":"Also Want It In Another Language? "},{"location":"adt.html","text":"Abstract Class IQueue \u00b6 Bases: Sized , Iterable IQueue provides an interface for the Queue ADT that supports the Pythonic way of iterating over elements and querying collection size. Implementations of this ADT must implement the abstract methods __len__() , __iter__() , front() , enqueue() , and dequeue() . In addition, the abstract property element_type also has to be implemented, and it is suggested to acquire this data via __init__() with an argument of type pydsa.utils.ElemTypeName . Source code in pydsa/queue/adt.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class IQueue ( Sized , Iterable ): \"\"\"`IQueue` provides an interface for the Queue ADT that supports the Pythonic way of iterating over elements and querying collection size. Implementations of this ADT must implement the abstract methods `__len__()`, `__iter__()`, `front()`, `enqueue()`, and `dequeue()`. In addition, the abstract property `element_type` also has to be implemented, and it is suggested to acquire this data via `__init__()` with an argument of type `pydsa.utils.ElemTypeName`. \"\"\" @property def empty ( self ) -> bool : \"\"\"Checks if the queue is empty. Returns: bool: True if the queue contains no elements. \"\"\" return len ( self ) == 0 def __str__ ( self ) -> str : \"\"\"String representation of the queue, listing elements in queue order from left to right. Example: `[3,1,4,1,5]` Returns: str: The string representation. \"\"\" s = '[' if not self . empty : itr = iter ( self ) s = f ' { s }{ next ( itr ) } ' for elem in itr : s = f ' { s } , { elem } ' s = f ' { s } ]' return s @property @abstractmethod def element_type ( self ) -> ElemTypeName : \"\"\"String representation of the type of each element in the queue. Returns: Type: The element type string. \"\"\" @abstractmethod def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. \"\"\" @abstractmethod def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" @abstractmethod def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: _description_ \"\"\" __str__ () \u00b6 String representation of the queue, listing elements in queue order from left to right. Example [3,1,4,1,5] Returns: Name Type Description str str The string representation. Source code in pydsa/queue/adt.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __str__ ( self ) -> str : \"\"\"String representation of the queue, listing elements in queue order from left to right. Example: `[3,1,4,1,5]` Returns: str: The string representation. \"\"\" s = '[' if not self . empty : itr = iter ( self ) s = f ' { s }{ next ( itr ) } ' for elem in itr : s = f ' { s } , { elem } ' s = f ' { s } ]' return s dequeue () abstractmethod \u00b6 Removes the front element from the queue if it is not empty. Returns: Name Type Description Elem Elem description Source code in pydsa/queue/adt.py 82 83 84 85 86 87 88 @abstractmethod def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: _description_ \"\"\" element_type () property abstractmethod \u00b6 String representation of the type of each element in the queue. Returns: Name Type Description Type ElemTypeName The element type string. Source code in pydsa/queue/adt.py 57 58 59 60 61 62 63 64 @property @abstractmethod def element_type ( self ) -> ElemTypeName : \"\"\"String representation of the type of each element in the queue. Returns: Type: The element type string. \"\"\" empty () property \u00b6 Checks if the queue is empty. Returns: Name Type Description bool bool True if the queue contains no elements. Source code in pydsa/queue/adt.py 28 29 30 31 32 33 34 35 @property def empty ( self ) -> bool : \"\"\"Checks if the queue is empty. Returns: bool: True if the queue contains no elements. \"\"\" return len ( self ) == 0 enqueue ( elem ) abstractmethod \u00b6 Inserts an element at the end of the queue. Parameters: Name Type Description Default elem Elem The element to insert. required Source code in pydsa/queue/adt.py 74 75 76 77 78 79 80 @abstractmethod def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" front () abstractmethod \u00b6 Gets the element at the front of the queue if it is not empty. Returns: Name Type Description Elem Elem The front element. Source code in pydsa/queue/adt.py 66 67 68 69 70 71 72 @abstractmethod def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. \"\"\"","title":"Queue ADT"},{"location":"adt.html#abstract-class-iqueue","text":"Bases: Sized , Iterable IQueue provides an interface for the Queue ADT that supports the Pythonic way of iterating over elements and querying collection size. Implementations of this ADT must implement the abstract methods __len__() , __iter__() , front() , enqueue() , and dequeue() . In addition, the abstract property element_type also has to be implemented, and it is suggested to acquire this data via __init__() with an argument of type pydsa.utils.ElemTypeName . Source code in pydsa/queue/adt.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class IQueue ( Sized , Iterable ): \"\"\"`IQueue` provides an interface for the Queue ADT that supports the Pythonic way of iterating over elements and querying collection size. Implementations of this ADT must implement the abstract methods `__len__()`, `__iter__()`, `front()`, `enqueue()`, and `dequeue()`. In addition, the abstract property `element_type` also has to be implemented, and it is suggested to acquire this data via `__init__()` with an argument of type `pydsa.utils.ElemTypeName`. \"\"\" @property def empty ( self ) -> bool : \"\"\"Checks if the queue is empty. Returns: bool: True if the queue contains no elements. \"\"\" return len ( self ) == 0 def __str__ ( self ) -> str : \"\"\"String representation of the queue, listing elements in queue order from left to right. Example: `[3,1,4,1,5]` Returns: str: The string representation. \"\"\" s = '[' if not self . empty : itr = iter ( self ) s = f ' { s }{ next ( itr ) } ' for elem in itr : s = f ' { s } , { elem } ' s = f ' { s } ]' return s @property @abstractmethod def element_type ( self ) -> ElemTypeName : \"\"\"String representation of the type of each element in the queue. Returns: Type: The element type string. \"\"\" @abstractmethod def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. \"\"\" @abstractmethod def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" @abstractmethod def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: _description_ \"\"\"","title":"Abstract Class IQueue"},{"location":"adt.html#pydsa.queue.adt.IQueue.__str__","text":"String representation of the queue, listing elements in queue order from left to right. Example [3,1,4,1,5] Returns: Name Type Description str str The string representation. Source code in pydsa/queue/adt.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __str__ ( self ) -> str : \"\"\"String representation of the queue, listing elements in queue order from left to right. Example: `[3,1,4,1,5]` Returns: str: The string representation. \"\"\" s = '[' if not self . empty : itr = iter ( self ) s = f ' { s }{ next ( itr ) } ' for elem in itr : s = f ' { s } , { elem } ' s = f ' { s } ]' return s","title":"__str__()"},{"location":"adt.html#pydsa.queue.adt.IQueue.dequeue","text":"Removes the front element from the queue if it is not empty. Returns: Name Type Description Elem Elem description Source code in pydsa/queue/adt.py 82 83 84 85 86 87 88 @abstractmethod def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: _description_ \"\"\"","title":"dequeue()"},{"location":"adt.html#pydsa.queue.adt.IQueue.element_type","text":"String representation of the type of each element in the queue. Returns: Name Type Description Type ElemTypeName The element type string. Source code in pydsa/queue/adt.py 57 58 59 60 61 62 63 64 @property @abstractmethod def element_type ( self ) -> ElemTypeName : \"\"\"String representation of the type of each element in the queue. Returns: Type: The element type string. \"\"\"","title":"element_type()"},{"location":"adt.html#pydsa.queue.adt.IQueue.empty","text":"Checks if the queue is empty. Returns: Name Type Description bool bool True if the queue contains no elements. Source code in pydsa/queue/adt.py 28 29 30 31 32 33 34 35 @property def empty ( self ) -> bool : \"\"\"Checks if the queue is empty. Returns: bool: True if the queue contains no elements. \"\"\" return len ( self ) == 0","title":"empty()"},{"location":"adt.html#pydsa.queue.adt.IQueue.enqueue","text":"Inserts an element at the end of the queue. Parameters: Name Type Description Default elem Elem The element to insert. required Source code in pydsa/queue/adt.py 74 75 76 77 78 79 80 @abstractmethod def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\"","title":"enqueue()"},{"location":"adt.html#pydsa.queue.adt.IQueue.front","text":"Gets the element at the front of the queue if it is not empty. Returns: Name Type Description Elem Elem The front element. Source code in pydsa/queue/adt.py 66 67 68 69 70 71 72 @abstractmethod def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. \"\"\"","title":"front()"},{"location":"algos.html","text":"pydsa.queue.algo is a subpackage that contains ADT-implementation-agnostic algorithms on the Queue ADT. All algorithms are independent of implementation of the Queue ADT. merge ( queue1 , queue2 , compare ) \u00b6 Stable-merges two queues. Elements are compared using the binary predicate compare to determine the order in which they appear in the merged queue. Relative order of elements in the original queues are preserved. A new queue of the same type as the two queues to merge is created and returned if both queues to merge are not empty. Parameters: Name Type Description Default queue1 IQueue A queue to merge. required queue2 IQueue Another queue to merge. required compare Callable [[ IQueue , IQueue ], bool ] The binary predicate that governs how elements from the original queues are prioritized during merging. required Returns: Name Type Description IQueue IQueue The merged queue. Notes The complexity of the merge algorithm is O(n1 + n2) in both time and space, where n1 and n2 are the sizes of the two queues to merge. Source code in pydsa/queue/algo/merge.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def merge ( queue1 : IQueue , queue2 : IQueue , compare : Callable [[ IQueue , IQueue ], bool ]) -> IQueue : \"\"\"Stable-merges two queues. Elements are compared using the binary predicate ``compare`` to determine the order in which they appear in the merged queue. Relative order of elements in the original queues are preserved. A new queue of the same type as the two queues to merge is created and returned if both queues to merge are not empty. Args: queue1 (IQueue): A queue to merge. queue2 (IQueue): Another queue to merge. compare (Callable[[IQueue, IQueue], bool]): The binary predicate that governs how elements from the original queues are prioritized during merging. Returns: IQueue: The merged queue. Notes: The complexity of the merge algorithm is `O(n1 + n2)` in both time and space, where ``n1`` and ``n2`` are the sizes of the two queues to merge. \"\"\" n1 = len ( queue1 ) n2 = len ( queue2 ) if n1 == 0 : return queue2 if n2 == 0 : return queue1 # Create an empty queue of the same type as input queues # to store the merged sequence merged = type ( queue1 )[ type ( queue1 . front ())]( n1 + n2 , queue1 . element_type ) # Compare the elements at the front of two queues while not queue1 . empty and not queue2 . empty : queue = queue1 if compare ( queue1 . front (), queue2 . front ()) else queue2 merged . enqueue ( queue . front ()) queue . dequeue () # Handle unprocessed tail queue = queue1 if not queue1 . empty else queue2 while not queue . empty : merged . enqueue ( queue . front ()) queue . dequeue () return merged","title":"Algorithms on Queue ADT"},{"location":"algos.html#pydsa.queue.algo.merge.merge","text":"Stable-merges two queues. Elements are compared using the binary predicate compare to determine the order in which they appear in the merged queue. Relative order of elements in the original queues are preserved. A new queue of the same type as the two queues to merge is created and returned if both queues to merge are not empty. Parameters: Name Type Description Default queue1 IQueue A queue to merge. required queue2 IQueue Another queue to merge. required compare Callable [[ IQueue , IQueue ], bool ] The binary predicate that governs how elements from the original queues are prioritized during merging. required Returns: Name Type Description IQueue IQueue The merged queue. Notes The complexity of the merge algorithm is O(n1 + n2) in both time and space, where n1 and n2 are the sizes of the two queues to merge. Source code in pydsa/queue/algo/merge.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def merge ( queue1 : IQueue , queue2 : IQueue , compare : Callable [[ IQueue , IQueue ], bool ]) -> IQueue : \"\"\"Stable-merges two queues. Elements are compared using the binary predicate ``compare`` to determine the order in which they appear in the merged queue. Relative order of elements in the original queues are preserved. A new queue of the same type as the two queues to merge is created and returned if both queues to merge are not empty. Args: queue1 (IQueue): A queue to merge. queue2 (IQueue): Another queue to merge. compare (Callable[[IQueue, IQueue], bool]): The binary predicate that governs how elements from the original queues are prioritized during merging. Returns: IQueue: The merged queue. Notes: The complexity of the merge algorithm is `O(n1 + n2)` in both time and space, where ``n1`` and ``n2`` are the sizes of the two queues to merge. \"\"\" n1 = len ( queue1 ) n2 = len ( queue2 ) if n1 == 0 : return queue2 if n2 == 0 : return queue1 # Create an empty queue of the same type as input queues # to store the merged sequence merged = type ( queue1 )[ type ( queue1 . front ())]( n1 + n2 , queue1 . element_type ) # Compare the elements at the front of two queues while not queue1 . empty and not queue2 . empty : queue = queue1 if compare ( queue1 . front (), queue2 . front ()) else queue2 merged . enqueue ( queue . front ()) queue . dequeue () # Handle unprocessed tail queue = queue1 if not queue1 . empty else queue2 while not queue . empty : merged . enqueue ( queue . front ()) queue . dequeue () return merged","title":"merge()"},{"location":"api.html","text":"Abstract Data Type & Implementations \u00b6 The pydsa.queue namespace contains: Abstract class IQueue : Interface for the Queue ADT Implementations of the Queue ADT: Class CircArrayQueue : Circular Array Queue Class LinkedListQueue : Linked List Queue Utility functions that the above relies upon. Algorithms \u00b6 The pydsa.queue.algo namespace contains ADT-implementation-agnostic algorithms on the Queue ADT. merge(queue1, queue2, compare) : Stable-merges two queues.","title":"Overview"},{"location":"api.html#abstract-data-type-implementations","text":"The pydsa.queue namespace contains: Abstract class IQueue : Interface for the Queue ADT Implementations of the Queue ADT: Class CircArrayQueue : Circular Array Queue Class LinkedListQueue : Linked List Queue Utility functions that the above relies upon.","title":"Abstract Data Type &amp; Implementations"},{"location":"api.html#algorithms","text":"The pydsa.queue.algo namespace contains ADT-implementation-agnostic algorithms on the Queue ADT. merge(queue1, queue2, compare) : Stable-merges two queues.","title":"Algorithms"},{"location":"circ_array_queue.html","text":"Class CircArrayQueue \u00b6 Bases: IQueue , Generic [ Elem ] A generic unbounded queue -- an implementation of the Queue ADT using circular array with a dynamic resizing scheme. Source code in pydsa/queue/circ_array_queue.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class CircArrayQueue ( IQueue , Generic [ Elem ]): \"\"\" A generic unbounded queue -- an implementation of the Queue ADT using circular array with a dynamic resizing scheme. \"\"\" def __init__ ( self , init_cap : int , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue that can initially store `init_cap` number of elements of `elem_type`. Args: init_cap (int): Initial capacity of the queue. elem_type (ElemTypeName): Element type. Raises: ValueError: If `init_cap` is not a positive integer. \"\"\" if init_cap <= 0 : raise ValueError ( f 'init_cap ( { init_cap } ) must be a positive integer' ) self . _elems = py_obj_array_type ( init_cap , elem_type )() self . _elem_type = elem_type self . _start_idx = 0 self . _num_elems = 0 def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" for i in range ( len ( self )): idx = ( self . _start_idx + i ) % self . _capacity yield self . _elems [ idx ] @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type @property def _capacity ( self ) -> int : # Returns the maximum number of elements that the queue can store. return len ( self . _elems ) @property def _end_idx ( self ) -> int : # Returns the one-past-the-end position of the queue. return ( self . _start_idx + len ( self )) % self . _capacity def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) return self . _elems [ self . _start_idx ] def _resize ( self , kind : Literal [ 'grow' , 'shrink' ]) -> None : # Realizes the dynamic resizing scheme. curr_sz = len ( self ) arr = None # Double underlying array if queue is full. if kind == 'grow' and curr_sz == self . _capacity : arr = py_obj_array_type ( curr_sz * 2 , self . _elem_type )() for i , elem in enumerate ( self ): arr [ i ] = elem # Shrink underlying array by half if size is no greater than a quarter # of the queue's capacity. elif ( kind == 'shrink' and self . _capacity >= 2 and curr_sz * 4 < self . _capacity ): arr = py_obj_array_type ( self . _capacity // 2 , self . _elem_type )() for i , elem in enumerate ( self ): arr [ i ] = elem if arr : del self . _elems self . _elems = arr self . _start_idx = 0 def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" self . _resize ( 'grow' ) self . _elems [ self . _end_idx ] = elem self . _num_elems += 1 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) elem = self . _elems [ self . _start_idx ] self . _num_elems -= 1 self . _start_idx = ( self . _start_idx + 1 ) % self . _capacity self . _resize ( 'shrink' ) return elem __init__ ( init_cap , elem_type ) \u00b6 Creates an empty queue that can initially store init_cap number of elements of elem_type . Parameters: Name Type Description Default init_cap int Initial capacity of the queue. required elem_type ElemTypeName Element type. required Raises: Type Description ValueError If init_cap is not a positive integer. Source code in pydsa/queue/circ_array_queue.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , init_cap : int , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue that can initially store `init_cap` number of elements of `elem_type`. Args: init_cap (int): Initial capacity of the queue. elem_type (ElemTypeName): Element type. Raises: ValueError: If `init_cap` is not a positive integer. \"\"\" if init_cap <= 0 : raise ValueError ( f 'init_cap ( { init_cap } ) must be a positive integer' ) self . _elems = py_obj_array_type ( init_cap , elem_type )() self . _elem_type = elem_type self . _start_idx = 0 self . _num_elems = 0 __iter__ () \u00b6 Iterates over all elements from the front to the end of the queue. Yields: Type Description Generator [ Elem , None, None] The next unprocessed element. Source code in pydsa/queue/circ_array_queue.py 49 50 51 52 53 54 55 56 57 def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" for i in range ( len ( self )): idx = ( self . _start_idx + i ) % self . _capacity yield self . _elems [ idx ] __len__ () \u00b6 Returns the number of elements in the queue. Returns: Name Type Description int int Queue size. Source code in pydsa/queue/circ_array_queue.py 41 42 43 44 45 46 47 def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems dequeue () \u00b6 Removes the front element from the queue if it is not empty. Returns: Name Type Description Elem Elem The front element removed from the queue. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/circ_array_queue.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) elem = self . _elems [ self . _start_idx ] self . _num_elems -= 1 self . _start_idx = ( self . _start_idx + 1 ) % self . _capacity self . _resize ( 'shrink' ) return elem element_type () property \u00b6 Name of the type of each element in the queue. Source code in pydsa/queue/circ_array_queue.py 59 60 61 62 63 @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type enqueue ( elem ) \u00b6 Inserts an element at the end of the queue. Parameters: Name Type Description Default elem Elem The element to insert. required Source code in pydsa/queue/circ_array_queue.py 110 111 112 113 114 115 116 117 118 def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" self . _resize ( 'grow' ) self . _elems [ self . _end_idx ] = elem self . _num_elems += 1 front () \u00b6 Gets the element at the front of the queue if it is not empty. Returns: Name Type Description Elem Elem The front element. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/circ_array_queue.py 75 76 77 78 79 80 81 82 83 84 85 86 def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) return self . _elems [ self . _start_idx ]","title":"Circular Array Queue"},{"location":"circ_array_queue.html#class-circarrayqueue","text":"Bases: IQueue , Generic [ Elem ] A generic unbounded queue -- an implementation of the Queue ADT using circular array with a dynamic resizing scheme. Source code in pydsa/queue/circ_array_queue.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class CircArrayQueue ( IQueue , Generic [ Elem ]): \"\"\" A generic unbounded queue -- an implementation of the Queue ADT using circular array with a dynamic resizing scheme. \"\"\" def __init__ ( self , init_cap : int , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue that can initially store `init_cap` number of elements of `elem_type`. Args: init_cap (int): Initial capacity of the queue. elem_type (ElemTypeName): Element type. Raises: ValueError: If `init_cap` is not a positive integer. \"\"\" if init_cap <= 0 : raise ValueError ( f 'init_cap ( { init_cap } ) must be a positive integer' ) self . _elems = py_obj_array_type ( init_cap , elem_type )() self . _elem_type = elem_type self . _start_idx = 0 self . _num_elems = 0 def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" for i in range ( len ( self )): idx = ( self . _start_idx + i ) % self . _capacity yield self . _elems [ idx ] @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type @property def _capacity ( self ) -> int : # Returns the maximum number of elements that the queue can store. return len ( self . _elems ) @property def _end_idx ( self ) -> int : # Returns the one-past-the-end position of the queue. return ( self . _start_idx + len ( self )) % self . _capacity def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) return self . _elems [ self . _start_idx ] def _resize ( self , kind : Literal [ 'grow' , 'shrink' ]) -> None : # Realizes the dynamic resizing scheme. curr_sz = len ( self ) arr = None # Double underlying array if queue is full. if kind == 'grow' and curr_sz == self . _capacity : arr = py_obj_array_type ( curr_sz * 2 , self . _elem_type )() for i , elem in enumerate ( self ): arr [ i ] = elem # Shrink underlying array by half if size is no greater than a quarter # of the queue's capacity. elif ( kind == 'shrink' and self . _capacity >= 2 and curr_sz * 4 < self . _capacity ): arr = py_obj_array_type ( self . _capacity // 2 , self . _elem_type )() for i , elem in enumerate ( self ): arr [ i ] = elem if arr : del self . _elems self . _elems = arr self . _start_idx = 0 def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" self . _resize ( 'grow' ) self . _elems [ self . _end_idx ] = elem self . _num_elems += 1 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) elem = self . _elems [ self . _start_idx ] self . _num_elems -= 1 self . _start_idx = ( self . _start_idx + 1 ) % self . _capacity self . _resize ( 'shrink' ) return elem","title":"Class CircArrayQueue"},{"location":"circ_array_queue.html#pydsa.queue.circ_array_queue.CircArrayQueue.__init__","text":"Creates an empty queue that can initially store init_cap number of elements of elem_type . Parameters: Name Type Description Default init_cap int Initial capacity of the queue. required elem_type ElemTypeName Element type. required Raises: Type Description ValueError If init_cap is not a positive integer. Source code in pydsa/queue/circ_array_queue.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , init_cap : int , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue that can initially store `init_cap` number of elements of `elem_type`. Args: init_cap (int): Initial capacity of the queue. elem_type (ElemTypeName): Element type. Raises: ValueError: If `init_cap` is not a positive integer. \"\"\" if init_cap <= 0 : raise ValueError ( f 'init_cap ( { init_cap } ) must be a positive integer' ) self . _elems = py_obj_array_type ( init_cap , elem_type )() self . _elem_type = elem_type self . _start_idx = 0 self . _num_elems = 0","title":"__init__()"},{"location":"circ_array_queue.html#pydsa.queue.circ_array_queue.CircArrayQueue.__iter__","text":"Iterates over all elements from the front to the end of the queue. Yields: Type Description Generator [ Elem , None, None] The next unprocessed element. Source code in pydsa/queue/circ_array_queue.py 49 50 51 52 53 54 55 56 57 def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" for i in range ( len ( self )): idx = ( self . _start_idx + i ) % self . _capacity yield self . _elems [ idx ]","title":"__iter__()"},{"location":"circ_array_queue.html#pydsa.queue.circ_array_queue.CircArrayQueue.__len__","text":"Returns the number of elements in the queue. Returns: Name Type Description int int Queue size. Source code in pydsa/queue/circ_array_queue.py 41 42 43 44 45 46 47 def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems","title":"__len__()"},{"location":"circ_array_queue.html#pydsa.queue.circ_array_queue.CircArrayQueue.dequeue","text":"Removes the front element from the queue if it is not empty. Returns: Name Type Description Elem Elem The front element removed from the queue. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/circ_array_queue.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) elem = self . _elems [ self . _start_idx ] self . _num_elems -= 1 self . _start_idx = ( self . _start_idx + 1 ) % self . _capacity self . _resize ( 'shrink' ) return elem","title":"dequeue()"},{"location":"circ_array_queue.html#pydsa.queue.circ_array_queue.CircArrayQueue.element_type","text":"Name of the type of each element in the queue. Source code in pydsa/queue/circ_array_queue.py 59 60 61 62 63 @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type","title":"element_type()"},{"location":"circ_array_queue.html#pydsa.queue.circ_array_queue.CircArrayQueue.enqueue","text":"Inserts an element at the end of the queue. Parameters: Name Type Description Default elem Elem The element to insert. required Source code in pydsa/queue/circ_array_queue.py 110 111 112 113 114 115 116 117 118 def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" self . _resize ( 'grow' ) self . _elems [ self . _end_idx ] = elem self . _num_elems += 1","title":"enqueue()"},{"location":"circ_array_queue.html#pydsa.queue.circ_array_queue.CircArrayQueue.front","text":"Gets the element at the front of the queue if it is not empty. Returns: Name Type Description Elem Elem The front element. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/circ_array_queue.py 75 76 77 78 79 80 81 82 83 84 85 86 def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) return self . _elems [ self . _start_idx ]","title":"front()"},{"location":"demos.html","text":"Creating & Using Queues \u00b6 The following demo program shows how to create and perform operations on a circular array-based queue. src/pydsa/queue/circ_array_queue.py q = CircArrayQueue [ int ]( 4 , 'int' ) print ( f \"element type: ' { q . element_type } '\" ) for x in ( 3 , 1 , 4 , 1 , 5 ): q . enqueue ( x ) print ( q ) for x in q : print ( f ' { x } ' , end = '' ) print () while not q . empty : print ( f 'dequeue: front = { q . front () } | size = { len ( q ) } ' ) q . dequeue () print ( q , f '(queue is empty: { q . empty } )' ) To run the demo: $ python src/pydsa/queue/circ_array_queue.py Output: element type: 'int' [3,1,4,1,5] 3 1 4 1 5 dequeue: front = 3 | size = 5 dequeue: front = 1 | size = 4 dequeue: front = 4 | size = 3 dequeue: front = 1 | size = 2 dequeue: front = 5 | size = 1 [] (queue is empty: True) See Also : src/pydsa/queue/linked_list_queue.py is a similar demo program using the linked list based implementation instead. Merging Two Queues \u00b6 The following demo program shows how to perform a stable-merge of two (circular array-based) queues in which the element values imply the priority given when queues are merged. In the first part, the larger the value, the higher the priority (hence the use of operator.gt as argument compare ). In the second part, the smaller the value, the higher the priority (hence the use of operator.lt as argument compare ). src/pydsa/queue/algo/merge.py from operator import lt , gt from pydsa.queue import CircArrayQueue tests = ( # larger the value, higher the priority given when merged (( 4 , 7 , 2 , 10 ), ( 3 , 6 , 8 , 9 , 5 , 1 ), int , 'int' , gt ), # smaller the value, higher the priority given when merged (( 4 , 7 , 2 , 10 ), ( 3 , 6 , 8 , 9 , 5 , 1 ), int , 'int' , lt ) ) for nums1 , nums2 , t , t_name , cmp in tests : print ( f 'compare: { cmp } ' ) q1 = CircArrayQueue [ t ]( len ( nums1 ), t_name ) for num in nums1 : q1 . enqueue ( num ) print ( f 'q1 : { q1 } ' ) q2 = CircArrayQueue [ t ]( len ( nums2 ), t_name ) for num in nums2 : q2 . enqueue ( num ) print ( f 'q2 : { q2 } ' ) print ( 'merging q1 and q2...' ) merged = merge ( q1 , q2 , cmp ) print ( f 'merged : { merged } ' ) print () To run the demo: $ python src/pydsa/queue/algo/merge.py Output: compare: <built-in function gt> q1 : [4,7,2,10] q2 : [3,6,8,9,5,1] merging q1 and q2... merged : [4,7,3,6,8,9,5,2,10,1] compare: <built-in function lt> q1 : [4,7,2,10] q2 : [3,6,8,9,5,1] merging q1 and q2... merged : [3,4,6,7,2,8,9,5,1,10]","title":"Demo Programs"},{"location":"demos.html#creating-using-queues","text":"The following demo program shows how to create and perform operations on a circular array-based queue. src/pydsa/queue/circ_array_queue.py q = CircArrayQueue [ int ]( 4 , 'int' ) print ( f \"element type: ' { q . element_type } '\" ) for x in ( 3 , 1 , 4 , 1 , 5 ): q . enqueue ( x ) print ( q ) for x in q : print ( f ' { x } ' , end = '' ) print () while not q . empty : print ( f 'dequeue: front = { q . front () } | size = { len ( q ) } ' ) q . dequeue () print ( q , f '(queue is empty: { q . empty } )' ) To run the demo: $ python src/pydsa/queue/circ_array_queue.py Output: element type: 'int' [3,1,4,1,5] 3 1 4 1 5 dequeue: front = 3 | size = 5 dequeue: front = 1 | size = 4 dequeue: front = 4 | size = 3 dequeue: front = 1 | size = 2 dequeue: front = 5 | size = 1 [] (queue is empty: True) See Also : src/pydsa/queue/linked_list_queue.py is a similar demo program using the linked list based implementation instead.","title":"Creating &amp; Using Queues"},{"location":"demos.html#merging-two-queues","text":"The following demo program shows how to perform a stable-merge of two (circular array-based) queues in which the element values imply the priority given when queues are merged. In the first part, the larger the value, the higher the priority (hence the use of operator.gt as argument compare ). In the second part, the smaller the value, the higher the priority (hence the use of operator.lt as argument compare ). src/pydsa/queue/algo/merge.py from operator import lt , gt from pydsa.queue import CircArrayQueue tests = ( # larger the value, higher the priority given when merged (( 4 , 7 , 2 , 10 ), ( 3 , 6 , 8 , 9 , 5 , 1 ), int , 'int' , gt ), # smaller the value, higher the priority given when merged (( 4 , 7 , 2 , 10 ), ( 3 , 6 , 8 , 9 , 5 , 1 ), int , 'int' , lt ) ) for nums1 , nums2 , t , t_name , cmp in tests : print ( f 'compare: { cmp } ' ) q1 = CircArrayQueue [ t ]( len ( nums1 ), t_name ) for num in nums1 : q1 . enqueue ( num ) print ( f 'q1 : { q1 } ' ) q2 = CircArrayQueue [ t ]( len ( nums2 ), t_name ) for num in nums2 : q2 . enqueue ( num ) print ( f 'q2 : { q2 } ' ) print ( 'merging q1 and q2...' ) merged = merge ( q1 , q2 , cmp ) print ( f 'merged : { merged } ' ) print () To run the demo: $ python src/pydsa/queue/algo/merge.py Output: compare: <built-in function gt> q1 : [4,7,2,10] q2 : [3,6,8,9,5,1] merging q1 and q2... merged : [4,7,3,6,8,9,5,2,10,1] compare: <built-in function lt> q1 : [4,7,2,10] q2 : [3,6,8,9,5,1] merging q1 and q2... merged : [3,4,6,7,2,8,9,5,1,10]","title":"Merging Two Queues"},{"location":"installation.html","text":"Installing via pip \u00b6 $ pip install -U pydsa-queue","title":"Installation"},{"location":"installation.html#installing-via-pip","text":"$ pip install -U pydsa-queue","title":"Installing via pip"},{"location":"intro.html","text":"Using a Queue \u00b6 From the consumers' perspective, the pydsa-queue library provides various ready-to-use queue data structures that can store any kind of Python objects of both the primitive and user-defined types. Each queue implementation is a subclass of the abstract base class IQueue , which defines the common, standardized API, except the additional features specific to a particular implementation. Having chosen an implemented queue type and known the queue element type T , you instantiate a queue by calling the queue class's constructor with the element type described as both generic type hint (the actual type) and a constructor argument (one of the string literal defined in pydsa.queue.ElementTypeName . from pydsa.queue import CircArrayQueue q = CircArrayQueue [ int ]( 10 , 'int' ) print ( q . elem_type ) # prints int (a string, not type) In this example, the [int] part allows runtime type checking to make sure all queue elements are int s. The second argument 'int' is one of the possible element type category. For the circular array based implementation in particular, the constructor requires a positive integer as the first argument to determine how large a memory chunk should be allocated for the queue storage to start with. Now, you've an empty queue q awaiting data. for num in ( 3 , 1 , 4 , 1 ): q . enqueue ( num ) print ( len ( q )) # prints 4 You may then use the typical idiom to process the elements in the queue in the first-in-first-out (FIFO) manner. while not q . empty (): print ( f ' { q . front () } ' ) q . dequeue () print () # prints 3 1 4 1 print ( q . empty ()) # prints True Implementing Your Own Queue \u00b6 By design, all queue types are subclasses of the same abstract class IQueue , which specifies the interface of a conventional queue data structure. The class definition of the included implementation pydsa.queue.CircArrayQueue looks something like this: class CircArrayQueue ( IQueue , Generic [ Elem ]): Here, Elem specifies the queue element type. Let's say you're going to define a class MyQueue to implement the Queue ADT. Here is a blueprint to get you started: class MyQueue ( IQueue , Generic [ Elem ]): def __init__ ( self , elem_type : ElemTypeName , ... ) -> None : pass def __len__ ( self ) -> int : pass def __iter__ ( self ) -> Generator [ Elem , None , None ]: pass @property def element_type ( self ) -> ElemTypeName : pass def front ( self ) -> Elem : pass def enqueue ( self , elem : Elem ) -> None : pass def dequeue ( self ) -> Elem : pass }; To implement the abstract property elem_type , you're advised to acquire such data via the constructor and store it as a private instance field. This is it!","title":"A Quick Tour"},{"location":"intro.html#using-a-queue","text":"From the consumers' perspective, the pydsa-queue library provides various ready-to-use queue data structures that can store any kind of Python objects of both the primitive and user-defined types. Each queue implementation is a subclass of the abstract base class IQueue , which defines the common, standardized API, except the additional features specific to a particular implementation. Having chosen an implemented queue type and known the queue element type T , you instantiate a queue by calling the queue class's constructor with the element type described as both generic type hint (the actual type) and a constructor argument (one of the string literal defined in pydsa.queue.ElementTypeName . from pydsa.queue import CircArrayQueue q = CircArrayQueue [ int ]( 10 , 'int' ) print ( q . elem_type ) # prints int (a string, not type) In this example, the [int] part allows runtime type checking to make sure all queue elements are int s. The second argument 'int' is one of the possible element type category. For the circular array based implementation in particular, the constructor requires a positive integer as the first argument to determine how large a memory chunk should be allocated for the queue storage to start with. Now, you've an empty queue q awaiting data. for num in ( 3 , 1 , 4 , 1 ): q . enqueue ( num ) print ( len ( q )) # prints 4 You may then use the typical idiom to process the elements in the queue in the first-in-first-out (FIFO) manner. while not q . empty (): print ( f ' { q . front () } ' ) q . dequeue () print () # prints 3 1 4 1 print ( q . empty ()) # prints True","title":"Using a Queue"},{"location":"intro.html#implementing-your-own-queue","text":"By design, all queue types are subclasses of the same abstract class IQueue , which specifies the interface of a conventional queue data structure. The class definition of the included implementation pydsa.queue.CircArrayQueue looks something like this: class CircArrayQueue ( IQueue , Generic [ Elem ]): Here, Elem specifies the queue element type. Let's say you're going to define a class MyQueue to implement the Queue ADT. Here is a blueprint to get you started: class MyQueue ( IQueue , Generic [ Elem ]): def __init__ ( self , elem_type : ElemTypeName , ... ) -> None : pass def __len__ ( self ) -> int : pass def __iter__ ( self ) -> Generator [ Elem , None , None ]: pass @property def element_type ( self ) -> ElemTypeName : pass def front ( self ) -> Elem : pass def enqueue ( self , elem : Elem ) -> None : pass def dequeue ( self ) -> Elem : pass }; To implement the abstract property elem_type , you're advised to acquire such data via the constructor and store it as a private instance field. This is it!","title":"Implementing Your Own Queue"},{"location":"license.html","text":"BSD 3-Clause License Copyright (c) 2022, KriztoferY (https://github.com/KriztoferY) All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"linked_list_queue.html","text":"Class SLListQueue \u00b6 Bases: IQueue , Generic [ Elem ] A generic unbounded queue -- an implementation of the Queue ADT using a singly, circularly linked list with a dummy header node. Source code in pydsa/queue/sllist_queue.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class SLListQueue ( IQueue , Generic [ Elem ]): \"\"\" A generic unbounded queue -- an implementation of the Queue ADT using a singly, circularly linked list with a dummy header node. \"\"\" @dataclass class _Node : value : Optional [ Elem ] = None next : Optional [ \"SLListQueue._Node\" ] = None def __init__ ( self , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue. \"\"\" # dummy node whose successor is tail node of underlying linked list # when queue is not empty, `None` otherwise. self . _header = SLListQueue . _Node () self . _num_elems = 0 self . _elem_type = elem_type def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type def _tail ( self ) -> Optional [ \"_Node\" ]: # Gets the underlying linked list's tail node, which corresponds to # the last element at the end of the queue. return self . _header . next def _head ( self ) -> Optional [ \"_Node\" ]: # Gets the underlying linked list's head node, which corresponds to # the first element at the front of the queue. tail_node = self . _tail () return tail_node . next if tail_node else None def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" curr_node = self . _head () if curr_node is not None : for _ in range ( len ( self )): yield curr_node . value curr_node = curr_node . next def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) front_node = self . _head () return front_node . value if front_node else None def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" # create new tail node new_node = SLListQueue . _Node ( elem ) if not self . empty : # link new tail node to head node new_node . next = self . _head () # link old tail node to new tail node self . _tail () . next = new_node else : # link new tail node to itself as new head node new_node . next = new_node # link header node to new tail node self . _header . next = new_node # increment counter self . _num_elems += 1 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) # get a handle of old head node and its value head_node = self . _head () value = head_node . value # link tail node to successor of old head node self . _tail () . next = head_node . next # break old front node's link to new head node head_node . next = None # decrement counter self . _num_elems -= 1 # Help garbage collection del head_node return value __init__ ( elem_type ) \u00b6 Creates an empty queue. Source code in pydsa/queue/sllist_queue.py 28 29 30 31 32 33 34 35 def __init__ ( self , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue. \"\"\" # dummy node whose successor is tail node of underlying linked list # when queue is not empty, `None` otherwise. self . _header = SLListQueue . _Node () self . _num_elems = 0 self . _elem_type = elem_type __iter__ () \u00b6 Iterates over all elements from the front to the end of the queue. Yields: Type Description Generator [ Elem , None, None] The next unprocessed element. Source code in pydsa/queue/sllist_queue.py 62 63 64 65 66 67 68 69 70 71 72 def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" curr_node = self . _head () if curr_node is not None : for _ in range ( len ( self )): yield curr_node . value curr_node = curr_node . next __len__ () \u00b6 Returns the number of elements in the queue. Returns: Name Type Description int int Queue size. Source code in pydsa/queue/sllist_queue.py 37 38 39 40 41 42 43 def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems dequeue () \u00b6 Removes the front element from the queue if it is not empty. Returns: Name Type Description Elem Elem The front element removed from the queue. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/sllist_queue.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) # get a handle of old head node and its value head_node = self . _head () value = head_node . value # link tail node to successor of old head node self . _tail () . next = head_node . next # break old front node's link to new head node head_node . next = None # decrement counter self . _num_elems -= 1 # Help garbage collection del head_node return value element_type () property \u00b6 Name of the type of each element in the queue. Source code in pydsa/queue/sllist_queue.py 45 46 47 48 49 @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type enqueue ( elem ) \u00b6 Inserts an element at the end of the queue. Parameters: Name Type Description Default elem Elem The element to insert. required Source code in pydsa/queue/sllist_queue.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" # create new tail node new_node = SLListQueue . _Node ( elem ) if not self . empty : # link new tail node to head node new_node . next = self . _head () # link old tail node to new tail node self . _tail () . next = new_node else : # link new tail node to itself as new head node new_node . next = new_node # link header node to new tail node self . _header . next = new_node # increment counter self . _num_elems += 1 front () \u00b6 Gets the element at the front of the queue if it is not empty. Returns: Name Type Description Elem Elem The front element. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/sllist_queue.py 74 75 76 77 78 79 80 81 82 83 84 85 86 def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) front_node = self . _head () return front_node . value if front_node else None","title":"Linked List Queue"},{"location":"linked_list_queue.html#class-sllistqueue","text":"Bases: IQueue , Generic [ Elem ] A generic unbounded queue -- an implementation of the Queue ADT using a singly, circularly linked list with a dummy header node. Source code in pydsa/queue/sllist_queue.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class SLListQueue ( IQueue , Generic [ Elem ]): \"\"\" A generic unbounded queue -- an implementation of the Queue ADT using a singly, circularly linked list with a dummy header node. \"\"\" @dataclass class _Node : value : Optional [ Elem ] = None next : Optional [ \"SLListQueue._Node\" ] = None def __init__ ( self , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue. \"\"\" # dummy node whose successor is tail node of underlying linked list # when queue is not empty, `None` otherwise. self . _header = SLListQueue . _Node () self . _num_elems = 0 self . _elem_type = elem_type def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type def _tail ( self ) -> Optional [ \"_Node\" ]: # Gets the underlying linked list's tail node, which corresponds to # the last element at the end of the queue. return self . _header . next def _head ( self ) -> Optional [ \"_Node\" ]: # Gets the underlying linked list's head node, which corresponds to # the first element at the front of the queue. tail_node = self . _tail () return tail_node . next if tail_node else None def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" curr_node = self . _head () if curr_node is not None : for _ in range ( len ( self )): yield curr_node . value curr_node = curr_node . next def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) front_node = self . _head () return front_node . value if front_node else None def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" # create new tail node new_node = SLListQueue . _Node ( elem ) if not self . empty : # link new tail node to head node new_node . next = self . _head () # link old tail node to new tail node self . _tail () . next = new_node else : # link new tail node to itself as new head node new_node . next = new_node # link header node to new tail node self . _header . next = new_node # increment counter self . _num_elems += 1 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) # get a handle of old head node and its value head_node = self . _head () value = head_node . value # link tail node to successor of old head node self . _tail () . next = head_node . next # break old front node's link to new head node head_node . next = None # decrement counter self . _num_elems -= 1 # Help garbage collection del head_node return value","title":"Class SLListQueue"},{"location":"linked_list_queue.html#pydsa.queue.sllist_queue.SLListQueue.__init__","text":"Creates an empty queue. Source code in pydsa/queue/sllist_queue.py 28 29 30 31 32 33 34 35 def __init__ ( self , elem_type : ElemTypeName ) -> None : \"\"\"Creates an empty queue. \"\"\" # dummy node whose successor is tail node of underlying linked list # when queue is not empty, `None` otherwise. self . _header = SLListQueue . _Node () self . _num_elems = 0 self . _elem_type = elem_type","title":"__init__()"},{"location":"linked_list_queue.html#pydsa.queue.sllist_queue.SLListQueue.__iter__","text":"Iterates over all elements from the front to the end of the queue. Yields: Type Description Generator [ Elem , None, None] The next unprocessed element. Source code in pydsa/queue/sllist_queue.py 62 63 64 65 66 67 68 69 70 71 72 def __iter__ ( self ) -> Generator [ Elem , None , None ]: \"\"\"Iterates over all elements from the front to the end of the queue. Yields: The next unprocessed element. \"\"\" curr_node = self . _head () if curr_node is not None : for _ in range ( len ( self )): yield curr_node . value curr_node = curr_node . next","title":"__iter__()"},{"location":"linked_list_queue.html#pydsa.queue.sllist_queue.SLListQueue.__len__","text":"Returns the number of elements in the queue. Returns: Name Type Description int int Queue size. Source code in pydsa/queue/sllist_queue.py 37 38 39 40 41 42 43 def __len__ ( self ) -> int : \"\"\"Returns the number of elements in the queue. Returns: int: Queue size. \"\"\" return self . _num_elems","title":"__len__()"},{"location":"linked_list_queue.html#pydsa.queue.sllist_queue.SLListQueue.dequeue","text":"Removes the front element from the queue if it is not empty. Returns: Name Type Description Elem Elem The front element removed from the queue. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/sllist_queue.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def dequeue ( self ) -> Elem : \"\"\"Removes the front element from the queue if it is not empty. Returns: Elem: The front element removed from the queue. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot dequeue from an empty queue' ) # get a handle of old head node and its value head_node = self . _head () value = head_node . value # link tail node to successor of old head node self . _tail () . next = head_node . next # break old front node's link to new head node head_node . next = None # decrement counter self . _num_elems -= 1 # Help garbage collection del head_node return value","title":"dequeue()"},{"location":"linked_list_queue.html#pydsa.queue.sllist_queue.SLListQueue.element_type","text":"Name of the type of each element in the queue. Source code in pydsa/queue/sllist_queue.py 45 46 47 48 49 @property def element_type ( self ) -> ElemTypeName : \"\"\"Name of the type of each element in the queue. \"\"\" return self . _elem_type","title":"element_type()"},{"location":"linked_list_queue.html#pydsa.queue.sllist_queue.SLListQueue.enqueue","text":"Inserts an element at the end of the queue. Parameters: Name Type Description Default elem Elem The element to insert. required Source code in pydsa/queue/sllist_queue.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def enqueue ( self , elem : Elem ) -> None : \"\"\"Inserts an element at the end of the queue. Args: elem (Elem): The element to insert. \"\"\" # create new tail node new_node = SLListQueue . _Node ( elem ) if not self . empty : # link new tail node to head node new_node . next = self . _head () # link old tail node to new tail node self . _tail () . next = new_node else : # link new tail node to itself as new head node new_node . next = new_node # link header node to new tail node self . _header . next = new_node # increment counter self . _num_elems += 1","title":"enqueue()"},{"location":"linked_list_queue.html#pydsa.queue.sllist_queue.SLListQueue.front","text":"Gets the element at the front of the queue if it is not empty. Returns: Name Type Description Elem Elem The front element. Raises: Type Description RuntimeError If the queue is empty. Source code in pydsa/queue/sllist_queue.py 74 75 76 77 78 79 80 81 82 83 84 85 86 def front ( self ) -> Elem : \"\"\"Gets the element at the front of the queue if it is not empty. Returns: Elem: The front element. Raises: RuntimeError: If the queue is empty. \"\"\" if self . empty : raise RuntimeError ( 'cannot peek front element from empty queue' ) front_node = self . _head () return front_node . value if front_node else None","title":"front()"},{"location":"unittests.html","text":"A full suite of unit tests is included to cover all implementations of the Queue ADT and the generic algorithms on it. Requirement \u00b6 To run the tests, at the minimum, you need to install pytest if you've done so. $ pip install -U pytest Running Tests \u00b6 Then, to run all tests, simply execute the following at the project root directory: $ pytest -v","title":"Unit Tests"},{"location":"unittests.html#requirement","text":"To run the tests, at the minimum, you need to install pytest if you've done so. $ pip install -U pytest","title":"Requirement"},{"location":"unittests.html#running-tests","text":"Then, to run all tests, simply execute the following at the project root directory: $ pytest -v","title":"Running Tests"},{"location":"utils.html","text":"This module pydsa.utils contains utility functions that aid implementing abstract data types and algorithms. ElemTypeName = Literal [ 'int' , 'uint' , 'float' , 'double' , 'object' ] module-attribute \u00b6 All possible options for contiguous memory cell item type. is_pos_power_of_two ( num ) \u00b6 Checks if num is a positive power of 2. Parameters: Name Type Description Default num int The number to test. required Returns: Name Type Description bool bool True if num is a positive power of 2, False otherwise. Source code in pydsa/utils.py 48 49 50 51 52 53 54 55 56 57 def is_pos_power_of_two ( num : int ) -> bool : \"\"\"Checks if `num` is a positive power of 2. Args: num (int): The number to test. Returns: bool: `True` if `num` is a positive power of 2, `False` otherwise. \"\"\" return num > 0 and ( num & ( num - 1 ) == 0 ) py_obj_array_type ( size , item_type ) \u00b6 Creates and returns a type that represents contiguous memory cells for size number of objects of item_type . Parameters: Name Type Description Default item_type ElemTypeName Cell item type -- 'int', 'uint', 'float', 'double', 'object'. required Raises: Type Description ValueError if item_type is not one of allowed options. Returns: Name Type Description Type Type The contiguous memory cell type desired. See Also pydsa.utils.ElemTypeName Source code in pydsa/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def py_obj_array_type ( size : int , item_type : ElemTypeName ) -> Type : \"\"\"Creates and returns a type that represents contiguous memory cells for `size` number of objects of `item_type`. Args: item_type (ElemTypeName): Cell item type -- 'int', 'uint', 'float', 'double', 'object'. Raises: ValueError: if `item_type` is not one of allowed options. Returns: Type: The contiguous memory cell type desired. See Also: `pydsa.utils.ElemTypeName` \"\"\" if item_type == 'int' : item_type = ctypes . c_longlong elif item_type == 'uint' : item_type = ctypes . c_ulonglong elif item_type == 'float' : item_type = ctypes . c_float elif item_type == 'double' : item_type = ctypes . c_longdouble elif item_type == 'object' : item_type = ctypes . py_object else : raise ValueError ( 'Invalid argument item_type' ) return item_type * size validate_close_range ( name , value , low , high , error = IndexError ) \u00b6 Checks if the number value falls within the close range [low, high] . Parameters: Name Type Description Default name str Name of the number to check. required value int The number to check. required low int Beginning of the close range. required high int End of the close range. required error Type [ Exception ] The exception type to raise when the test fails. IndexError Raises: Type Description error if value falls outside the close range [low, high] . Source code in pydsa/utils.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def validate_close_range ( name : str , value : int , low : int , high : int , error : Type [ Exception ] = IndexError ) -> None : \"\"\"Checks if the number `value` falls within the close range `[low, high]`. Args: name (str): Name of the number to check. value (int): The number to check. low (int): Beginning of the close range. high (int): End of the close range. error (Type[Exception], optional): The exception type to raise when the test fails. Raises: error: if `value` falls outside the close range `[low, high]`. \"\"\" if value < low or value > high : raise error ( f ' { name } = { value } out of range [ { low } , { high } ]' )","title":"Utilities"},{"location":"utils.html#pydsa.utils.ElemTypeName","text":"All possible options for contiguous memory cell item type.","title":"ElemTypeName"},{"location":"utils.html#pydsa.utils.is_pos_power_of_two","text":"Checks if num is a positive power of 2. Parameters: Name Type Description Default num int The number to test. required Returns: Name Type Description bool bool True if num is a positive power of 2, False otherwise. Source code in pydsa/utils.py 48 49 50 51 52 53 54 55 56 57 def is_pos_power_of_two ( num : int ) -> bool : \"\"\"Checks if `num` is a positive power of 2. Args: num (int): The number to test. Returns: bool: `True` if `num` is a positive power of 2, `False` otherwise. \"\"\" return num > 0 and ( num & ( num - 1 ) == 0 )","title":"is_pos_power_of_two()"},{"location":"utils.html#pydsa.utils.py_obj_array_type","text":"Creates and returns a type that represents contiguous memory cells for size number of objects of item_type . Parameters: Name Type Description Default item_type ElemTypeName Cell item type -- 'int', 'uint', 'float', 'double', 'object'. required Raises: Type Description ValueError if item_type is not one of allowed options. Returns: Name Type Description Type Type The contiguous memory cell type desired. See Also pydsa.utils.ElemTypeName Source code in pydsa/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def py_obj_array_type ( size : int , item_type : ElemTypeName ) -> Type : \"\"\"Creates and returns a type that represents contiguous memory cells for `size` number of objects of `item_type`. Args: item_type (ElemTypeName): Cell item type -- 'int', 'uint', 'float', 'double', 'object'. Raises: ValueError: if `item_type` is not one of allowed options. Returns: Type: The contiguous memory cell type desired. See Also: `pydsa.utils.ElemTypeName` \"\"\" if item_type == 'int' : item_type = ctypes . c_longlong elif item_type == 'uint' : item_type = ctypes . c_ulonglong elif item_type == 'float' : item_type = ctypes . c_float elif item_type == 'double' : item_type = ctypes . c_longdouble elif item_type == 'object' : item_type = ctypes . py_object else : raise ValueError ( 'Invalid argument item_type' ) return item_type * size","title":"py_obj_array_type()"},{"location":"utils.html#pydsa.utils.validate_close_range","text":"Checks if the number value falls within the close range [low, high] . Parameters: Name Type Description Default name str Name of the number to check. required value int The number to check. required low int Beginning of the close range. required high int End of the close range. required error Type [ Exception ] The exception type to raise when the test fails. IndexError Raises: Type Description error if value falls outside the close range [low, high] . Source code in pydsa/utils.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def validate_close_range ( name : str , value : int , low : int , high : int , error : Type [ Exception ] = IndexError ) -> None : \"\"\"Checks if the number `value` falls within the close range `[low, high]`. Args: name (str): Name of the number to check. value (int): The number to check. low (int): Beginning of the close range. high (int): End of the close range. error (Type[Exception], optional): The exception type to raise when the test fails. Raises: error: if `value` falls outside the close range `[low, high]`. \"\"\" if value < low or value > high : raise error ( f ' { name } = { value } out of range [ { low } , { high } ]' )","title":"validate_close_range()"}]}